#!/usr/bin/perl
#
# ring-load - load pictures into a ring database
#

use strict;
use Cwd;
use DBI;
use File::Copy;
use File::Slurp;
use File::Spec;
use Getopt::Long;
use Image::ExifTool 'ImageInfo';
use Image::Magick;
use Pod::Usage;
use Rings::Common;

my %MIME_TYPES = ();
my %SIZE_IDS   = ();

my $opt_conf;
my $opt_debug;
my $opt_force;
my $opt_help;
my $opt_manual;

##############################################################################
# Subroutines
##############################################################################

# ------------------------------------------------
# return regex target string with all files types supported

sub get_file_types {
    my %file_types = ();
    for my $t (keys %MIME_TYPES) {
        $file_types{ $MIME_TYPES{$t} }++;
    }
    my $type_list = '';
    my $or        = '(';
    for my $t (keys %file_types) {
        $type_list .= $or . $t;
        $or = '|';
    }
    if ($or eq '|') {
        $type_list .= ')';
    }
    return $type_list;
}

# ------------------------------------------------
# process the files

sub save_file {

    (my $a_file) = @_;

    if ($CONF->debug) {
        dbg("Saving file: $a_file");
    }

    # Pull out the file name, the file type, and the parent directory
    my $a_fullname = File::Spec->rel2abs($a_file);
    my ($a_vol, $a_dirlist, $a_filename) = File::Spec->splitpath($a_fullname);
    my $a_filetype = '';
    if ($a_filename =~ /^(.*?)\.(.*)/xms) {
        $a_filename = $1;
        $a_filetype = $2;
    }
    $a_dirlist =~ s{^/}{}xms;
    $a_dirlist =~ s{/$}{}xms;
    my @dirs     = File::Spec->splitdir($a_dirlist);
    my $a_parent = $dirs[-1];

    my $blob = read_file("$a_file", binmode => ':raw');
    my %pic = get_meta_data($blob);

    # Check for duplicate picture
    my $dup_cnt = 0;
    my $sql     = "SELECT pid FROM pictures_information ";
    $sql .= "WHERE raw_picture_size = ? ";
    $sql .= "AND camera = ? ";
    $sql .= "AND shutter_speed = ? ";
    $sql .= "AND fstop = ?";
    if ($opt_debug) {
        dbg($sql);
    }
    my $sth = $DBH->prepare($sql);
    $sth->execute(
        $pic{size}, $pic{camera}, $pic{shutterspeed}, $pic{this_fnumber},
    );
    while (my $row = $sth->fetchrow_hashref()) {
        $dup_cnt++;
        msg("File $a_file duplicates $row->{pid}");
    }
    if ($dup_cnt and !$opt_force) {
        msg("SKIPPING: $a_file");
        return;
    }

    # Set the PID
    my $pid = get_next_id("pid");

    # Store meta-data and copy the raw picture to rings directory
    my $pic_path = create_picture_dirs($a_parent, 'raw');
    my $pic_base = "${pid}.${a_filetype}";
    my $pic_file = "${pic_path}/${pic_base}";
    $pic{'in_file'} = $pic_file;
    store_meta_data($pid, $a_fullname, \%pic);
    create_picture($pid, 'raw', $blob, $pic_base, $pic{'MIMEType'});
    copy($a_fullname, $pic_file)
      or msg('fatal', "Problem copying $a_file to $pic_file, $!");

    queue_status_set($pid);

    return;
}

##############################################################################
# Main Routine
##############################################################################

# -- get options
GetOptions(
    'conf=s' => \$opt_conf,
    'debug'  => \$opt_debug,
    'force'  => \$opt_force,
    'help'   => \$opt_help,
    'manual' => \$opt_manual
);

# help the poor souls out
if (@ARGV && $ARGV[0] eq 'help') {
    $opt_help = 1;
}
if ($opt_help) {
    pod2usage(-verbose => 0);
}
if ($opt_manual) {
    pod2usage(-verbose => 2);
}
if (!@ARGV) {
    msg('ERROR: directory specification required');
    pod2usage(-verbose => 0);
}
my @dir_list = @ARGV;

get_config($opt_conf);

if ($opt_debug) {
    $CONF->debug($opt_debug);
}
if ($CONF->debug) {
    dbg("Initialize timer.");
}

# -- Open up connections to the MySQL data
db_connect();

%MIME_TYPES = get_picture_types();
my $type_list = get_file_types();

%SIZE_IDS = get_picture_sizes();

my %file_list = ();
for my $this_dir (@dir_list) {
    if (!-d $this_dir) {
        msg('INFO: $this_dir not found ... skipping');
        next;
    }
    $this_dir =~ s{/$}{}xms;
    msg('info', "Examining files that match *.${type_list} in ${this_dir}");
    opendir(my $dh, $this_dir) || die "ERROR: problem opening $this_dir\n";
    while (readdir $dh) {
        my $f = $_;
        if ($f =~ /(.*?)\.$type_list$/xmsi) {
            my $full_path = "$this_dir/$f";
            $file_list{$full_path}++;
        }
    }
}
for my $f (sort keys %file_list) {
    save_file($f);
}

exit;

__END__

=head1 NAME

ring-load

=head1 SYNOPSIS

ring=load <directory1> [<directory2> ...] [--conf=<configuration>]
[--force] [--debug] [--help] [--manual]


=head1 DESCRIPTION

This script reads the jpeg files in a directory and loads the rings
database.  At least one directory specification is required.

=head1 OPTIONS AND ARGUMENTS

=over 4

=item --force

Override duplicate detection and store the pictures anyway.

=item --help

Displays help text.

=item --manual

Displays more complete help text.

=item --debug

Turns on debugging displays.

=back

=head1 AUTHOR

Bill MacAllister <bill@ca-zephyr.org>

=cut
