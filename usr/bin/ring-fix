#!/usr/bin/perl

use AppConfig qw(:argcount :expand);
use DBI;
use File::Slurp;
use File::Find;
use Getopt::Long;
use Image::Magick;
use Pod::Usage;
use strict;
use Time::Local;

my $CONF;
my $DBH;
my $DBH_UPDATE;
my $DEBUG_TIME;
my $UPDATE_CNT = 0;

my $opt_conf = 'rings.conf';
my $opt_example;
my $opt_debug;
my $opt_debug;
my $opt_help;
my $opt_manual;
my $opt_limit;
my $opt_update;

# ------------------------------------------------
# output debugging information

sub dbg {
    
    (my $tmp) = @_;
    
    my $now = time;
    my $elapsed = $now - $DEBUG_TIME;
    print "$now ($elapsed) $tmp \n";
    $DEBUG_TIME = $now;
    return;
    
}

# ------------------------------------------------
# output text

sub msg {
    (my $tmp) = @_;
    print $tmp;
    return;
}

# ------------------------------------------------
# sql date time string from unix time stamp

sub sql_datetime {
    
    my ($dt) = @_;
    
    if (length($dt)==0) {$dt = time}
    my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime($dt);
    $mon++;
    $year += 1900;
    
    return sprintf "%04d-%02d-%02d %02d:%02d:%02d",
    $year,$mon,$mday,$hour,$min,$sec;
}

# ------------------------------------------------
# unix time stamp from sql date time string

sub unix_seconds {
    
    my ($dt) = @_;
    
    my $ret = time;
    if ($dt =~ m/(\d+)\-(\d+)\-(\d+)\s+(\d+):(\d+):(\d+)/ ) {
        my $yyyy = $1;
        my $mm = $2;
        my $dd = $3;
        my $h = $4;
        my $m = $5;
        my $s = $6;
        $mm--;
        $ret = timelocal ($s, $m, $h, $dd, $mm, $yyyy);
    }
    return $ret;
}

# ------------------------------------------------
# Read configuration

sub read_conf {
    my $conf_file = '/etc/whm/rings.fix';
    if ($opt_conf) {
        $conf_file = $opt_conf;
    }

    my $conf = AppConfig->new({});
    $conf->define(
        'ring_root',
        {
            ARGCOUNT => ARGCOUNT_ONE,
            DEFAULT  => '/opt/rings'
        }
    );
    $conf->define(
        'db_host',
        {
            ARGCOUNT => ARGCOUNT_ONE,
            DEFAULT  => 'localhost'
        }
    );
    $conf->define(
        'db_name',
        {
            ARGCOUNT => ARGCOUNT_ONE,
            DEFAULT  => 'rings'
        }
    );
    $conf->define(
        'db_credentials',
        {
            ARGCOUNT => ARGCOUNT_ONE,
            DEFAULT  => '/etc/whm/rings_db.conf'
        }
    );

    if (-e $conf_file) {
        $conf->file($conf_file);
    } else {
        die("Configuration file is required");
    }

    # Read database credentials and add them to the $conf structure
    my $db_conf = AppConfig->new({});
    $db_conf->define('db_user', { ARGCOUNT => ARGCOUNT_ONE } );
    $db_conf->define('db_pass', { ARGCOUNT => ARGCOUNT_ONE } );
    if (-e $conf->db_credentials()) {
        $db_conf->file($conf->db_credentials());
    } else {
        msg('INFO: db_credentials = ' . $conf->db_credentials . "\n");
        die("Data base password and user required in configuration file.");
    }
    $conf->define('db_user');
    $conf->db_user($db_conf->db_user());
    $conf->define('db_pass');
    $conf->db_pass($db_conf->db_pass());
    
    return $conf;
}

sub example_conf {

    msg("# ----------------------------------------------------\n");
    msg("# Example /etc/whm/rings.conf\n");
    msg("#\n");
    msg("ring_root = /opt/rings\n");
    msg("db_host = localhost\n");
    msg("db_name = rings\n");
    msg("db_credentials = /etc/whm/rings_db.conf\n");
    msg("\n");
    msg("# ----------------------------------------------------\n");
    msg("# Example /etc/whm/rings_db.conf\n");
    msg("# ----------------------------------------------------\n");
    msg("#\n");
    msg("db_user = rings\n");
    msg("db_pass = pass\n");
    return;
}

# ------------------------------------------------------------------------
# Check files and make sure they are in the db

sub check_db{

    my $this_path = $File::Find::dir;
    my $this_file = $_;
    my $this_pid;
    if ($this_path !~ /\/raw$/xms) {
        return;
    }
    if ($this_file =~ /(\d+)[.](jpg|jpeg)/xmsi) {
        $this_pid = $1;
    } else {
        return;
    }

    if ($opt_debug) {
        dbg("this_path:$this_path this_file:$this_file this_pid:$this_pid");
    }

    my $sel = "SELECT pid,picture FROM pictures_raw WHERE pid = ?";
    my $sth = $DBH->prepare ($sel);
    if ($opt_debug) {dbg($sel);}
    $sth->execute($this_pid);
    my $cnt         = 0;
    my $picture_len = 0;
    while (my $row = $sth->fetchrow_hashref) {
        $cnt++;
        $picture_len = length($row->{picture});
    }
    if ($picture_len > 0) {
        return;
    }

    # read in the whole picture file
    my $this_picture = read_file("$this_path/$this_file", binmode => ':raw');

    # write the picture to the database
    my $this_date = sql_datetime();
    if ($cnt) {
        my $cmd = 'INSERT INTO pictures_raw ';
        $cmd .= "(pid, picture_type, picture, date_added, date_last_maint) ";
        $cmd .= "VALUES (?, ?, ?, ?, ?) ";
        $cmd .= "WHERE pid = ? ";
        if ($opt_debug) {dbg($cmd);}
        my $sth_update = $DBH_UPDATE->prepare ($cmd);
        if ($opt_update) {
            msg("Inserting $this_pid\n");
            $sth_update->execute($this_pid,
                                 'image/JPEG',
                                 $this_picture,
                                 $this_date,
                                 $this_date);
        } else {
            msg("Proposing to insert $this_pid\n");
        }
    } else {
        my $cmd = "UPDATE pictures_raw SET ";
        $cmd .= "picture = ? ";
        $cmd .= "WHERE pid = ? ";
        if ($opt_debug) {dbg($cmd);}
        my $sth_update = $DBH_UPDATE->prepare ($cmd);
        if ($opt_update) {
            msg("Updating $this_pid\n");
            $sth_update->execute($this_picture, $this_pid);
        } else {
            msg("Proposing to update $this_pid\n");
        }
    }
    $UPDATE_CNT++;
    if ($UPDATE_CNT => $opt_limit) {
        exit;
    }
    return;
}

# -------------
# Main routine
# -------------

print ">>> ring-fix                    v:27-Jun-2016\n";

# -- get options
GetOptions(
    'conf=s'  => \$opt_conf,
    'debug'   => \$opt_debug,
    'example' => \$opt_example,
    'help'    => \$opt_help,
    'limit=i' => \$opt_limit,
    'manual'  => \$opt_manual,
    'update'  => \$opt_update
    );

# -- help the poor souls out
if ($opt_help) {
    pod2usage(-verbose => 0);
}
if ($opt_manual) {
    pod2usage(-verbose => 1);
}
if ($opt_example) {
    example_conf();
    exit 1;
}

if ($opt_debug) {dbg ("Initialize timer.");}

$CONF = read_conf();

# -- Open up connections to the MySQL data
my $db_host = $CONF->db_host();
my $db_name = $CONF->db_name();
my $dbi     = "dbi:mysql:host=$db_host;database=$db_name";
$DBH = DBI->connect ($dbi, $CONF->db_user(), $CONF->db_pass())
    or die "ERROR: Can't connect to database $dbi for read\n";
$DBH->{LongTruncOk} = 1;
$DBH->{LongReadLen} = 10000000;
$DBH_UPDATE = DBI->connect ($dbi, $CONF->db_user(), $CONF->db_pass())
    or die "ERROR: Can't connect to database $dbi for write\n";

find(\&check_db, $CONF->ring_root());

$DBH->disconnect
    or die "MAC-F-DISCFAIL, Disconnect failed for $dbi (read)";
$DBH_UPDATE->disconnect
    or die "MAC-F-DISCFAIL, Disconnect failed for $dbi (update)";

exit;

__END__

=head1 NAME

ring-fix

=head1 SYNOPSIS

ring-fix [--update] [--debug] [--help] [--manual] [--conf=file]
[--example]

=head1 DESCRIPTION

Restore raw pictures in database from file.

=head1 OPTIONS AND ARGUMENTS

=over 4

=item --conf=file

Configuration file defaults to ./ring-fix.conf.

=item --example

Print an example configuration file and exit.

=item --update

Actually load the data into the rings database.

=item --help

Displays help text.

=item --manual

Displays more complete help text.

=item --debug

Turns on debugging displays.

=back

=head1 AUTHOR

Bill MacAllister <bill@ca-zephyr.org>

=cut

