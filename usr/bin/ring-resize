#!/usr/bin/perl

# File: ring-resize
# Author: Bill MacAllister

use strict;
use Cwd;
use DBI;
use File::Slurp;
use Getopt::Long;
use Image::ExifTool 'ImageInfo';
use Image::Magick;
use Pod::Usage;
use Rings::Common;

my %SIZE_IDS = ();

my $opt_conf;
my $opt_debug;
my $opt_help;
my $opt_manual;
my $opt_oneshot;

##############################################################################
# Subroutines
##############################################################################

# ------------------------------------------------------------------------
# Look up a list of pids to process and run a hash of pids and
# picture_lots.

sub get_pids {
    my ($pid_start, $pid_end) = @_;

    my %pid_list = ();

    if ($pid_start == 'pending') {
        my $sel = 'SELECT picture_resize_queue.pid, ';
        $sel .= 'pictures_information.picture_lot ';
        $sel .= 'FROM picture_resize_queue ';
        $sel .= 'JOIN pictures_information ';
        $sel .= 'ON (pictures_information.pid = picture_resize_queue.pid) ';
        $sel .= "WHERE picture_resize_queue.status = 'PENDING' ";
        $sel .= 'ORDER BY pid ';
        if ($CONF->debug) {
            dbg($sel);
        }

        my $sth = $DBH->prepare($sel);
        $sth->execute();
        while (my $row = $sth->fetchrow_hashref) {
            $pid_list{ $row->{pid} } = $row->{picture_lot};
        }
    } else {
        my $sel = 'SELECT pid, picture_lot ';
        $sel .= 'FROM pictures_information ';
        $sel .= 'WHERE pid >= ? AND pid <= ? ';
        $sel .= 'ORDER BY pid ';
        if ($CONF->debug) {
            dbg($sel);
        }

        my $sth = $DBH->prepare($sel);
        $sth->execute($pid_start, $pid_end);
        while (my $row = $sth->fetchrow_hashref) {
            $pid_list{ $row->{pid} } = $row->{picture_lot};
        }
    }

    return %pid_list;
}

# ------------------------------------------------------------------------
# Read the raw file, scale the pictures, store the results

sub read_and_update {
    my %pid_list = @_;

    # process the pictures

    my $cnt = 0;
    foreach my $pid (sort keys %pid_list) {
        msg('info', "Resizing $pid");
        my $sel = 'SELECT pictures_raw.mime_type, ';
        $sel .= 'pictures_information.picture_lot, ';
        $sel .= 'picture_types.file_type ';
        $sel .= 'FROM pictures_raw ';
        $sel .= 'JOIN pictures_information ';
        $sel .= 'ON (pictures_information.pid = pictures_raw.pid) ';
        $sel .= 'JOIN picture_types ';
        $sel .= 'ON (picture_types.mime_type = pictures_raw.mime_type) ';
        $sel .= 'WHERE pictures_raw.pid = ? ';
        if ($CONF->debug) {
            dbg($sel);
        }

        my $sth = $DBH->prepare($sel);
        $sth->execute($pid);
        my $pic_lot;
        my $raw_mime_type;
        my $raw_file_type;
        if (my $row = $sth->fetchrow_hashref) {
            $pic_lot       = $row->{picture_lot};
            $raw_mime_type = $row->{mime_type};
            $raw_file_type = $row->{file_type};
        } else {
            msg('error', "PROBLEM SQL: $sel");
            my $msg = "Problems getting raw_picture information for $pid";
            msg('error', $msg);
            queue_error($pid, $msg);
            next;
        }

        # Get the raw picture
        my $raw_file = "${pid}.$raw_file_type";
        my $pic_path = $CONF->picture_root . "/$pic_lot/raw/$raw_file";
        if (!-e $pic_path || -d $pic_path) {
            my $msg = "Raw picture not found for $pid ($pic_path)";
            msg('error', $msg);
            queue_error($pid, $msg);
            next;
        }
        my $pic_size = -s $pic_path;
        if ($pic_size < 1) {
            my $msg = "Raw picture is zero length for $pid ($pic_path)";
            msg('error', $msg);
            queue_error($pid, $msg);
            next;
        }

        my $raw = read_file("$pic_path", binmode => ':raw');
        my ($mime_type, $file_type) = validate_mime_type($raw);
        foreach my $s (sort keys %SIZE_IDS) {
            my $ppath = create_picture_dirs($pid_list{$pid}, $s);
            my $pbase = "${pid}.${file_type}";
            my $pfile = "${ppath}/${pbase}";
            my $pic   = create_picture($pid, $s, $raw, $pbase, $mime_type);
            if ($s ne 'raw') {
                open(my $fh, '>', $pfile);
                print $fh $pic;
                close $fh;
            }
        }
        queue_status_reset($pid);
    }
    return;
}

##############################################################################
# Main Routine
##############################################################################

# -- get options
GetOptions(
    'conf=s'  => \$opt_conf,
    'debug'   => \$opt_debug,
    'help'    => \$opt_help,
    'manual'  => \$opt_manual,
    'oneshot' => \$opt_oneshot
);

# help the poor souls out
if (@ARGV && $ARGV[0] eq 'help') {
    $opt_help = 1;
}
if ($opt_help) {
    pod2usage(-verbose => 0);
}
if ($opt_manual) {
    pod2usage(-verbose => 2);
}

# Set the picture range to process from the command line
my $pid_start = 'pending';
if ($ARGV[0]) {
    $pid_start = $ARGV[0];
    if ($pid_start < 1 && $pid_start ne 'pending') {
        msg('info', 'ERROR: a starting pid or "pending" is required');
        pod2usage(-verbose => 0);
    }
}
my $pid_end = $pid_start;
if ($ARGV[1]) {
    $pid_end = $ARGV[1];
}

# Get configuration settings and initial debugging if requested.
get_config($opt_conf);
if ($opt_debug) {
    $CONF->debug($opt_debug);
}
if ($CONF->debug) {
    dbg("Initialize timer.");
}

# Open up connections to the MySQL data
db_connect();
%SIZE_IDS = get_picture_sizes();

my $loop = 1;
while ($loop) {
    if ($opt_oneshot || $pid_start > 0) {
        $loop = 0;
    }
    my %pid_list = get_pids($pid_start, $pid_end);
    if (keys %pid_list > 0) {
        read_and_update(%pid_list);
    } elsif (!$opt_oneshot) {
        sleep $CONF->queue_sleep;
    }
}

db_disconnect();

exit;

__END__

=head1 NAME

ring-resize

=head1 SYNOPSIS

ring-resize <start pid>|pending [<end pid>] [--oneshot] [--debug]
[--help] [--manual]

=head1 DESCRIPTION

Resize pictures in the rings database.  This script will regenerate
all picture sizes.  If pending the script will processing the entries
in the picture_resize_queue table continuously, sleeping when there
are no entries in the queue.  If --oneshot is specified with pending
then the queue table is read once and the script exits after
processing the queue entries read.

If there are problems with a queue entry its status is set to ERROR
and an error message is stored in the picture_resize_queue table.
This effectively removes the entry from resize processing.

=head1 OPTIONS AND ARGUMENTS

=over 4

=item --start=int

The picture id to start at.  Required.

=item --end=int

The picture id to end at.

=item --oneshot

Process the pending queue entries once and then exit.

=item --help

Displays help text.

=item --manual

Displays more complete help text.

=item --debug

Turns on debugging displays.

=back

=head1 AUTHOR

Bill MacAllister <bill@ca-zephyr.org>

=cut
