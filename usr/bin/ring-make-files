#!/usr/bin/perl
#
# ring-make-files - Take and input director and produce ring image
# files.
#

use Carp;
use Cwd;
use DBI;
use File::Copy;
use File::Find;
use Getopt::Long;
use Image::ExifTool 'ImageInfo';
use Image::Magick;
use Pod::Usage;
use strict;
use Time::Local;

my $CNT;
my $DBH;
my $DEBUG_TIME;
my %PICTURE_SIZES;
my $TYPE_LIST = '(gif|jpeg|jpg|png)';

my $opt_db = 'rings';
my $opt_db_host = 'spowl.ca-zephyr.org';
my $opt_db_pass;
my $opt_db_user;
my $opt_debug;
my $opt_help;
my $opt_inroot;
my $opt_manual;
my $opt_outroot = '/srv/rings';
my $opt_replace;
my $opt_update;

# ------------------------------------------------
# output debugging information

sub dbg {
    
    (my $tmp) = @_;
    
    my $now = time;
    my $elapsed = $now - $DEBUG_TIME;
    print "$now ($elapsed) $tmp \n";
    $DEBUG_TIME = $now;
    return;
    
}

# ------------------------------------------------
# Read picture sizes

sub read_picture_sizes {
    
    my $sel = "SELECT size_id, max_height, max_width ";
    $sel .= "FROM picture_sizes";
    if ($opt_debug) {dbg($sel);}
    my $sth = $DBH->prepare ($sel);
    $sth->execute();
    my %sizes = ();
    while (my $row = $sth->fetchrow_hashref) {
        $sizes{ $row->{size_id} }{'x'} = $row->{max_width};
        $sizes{ $row->{size_id} }{'y'} = $row->{max_height};
    }
    return %sizes;
}

# ------------------------------------------------
# Make picture files

sub make_picture_files {

    my $this_file      = $_;
    my $this_path      = $File::Find::dir;
    my $this_full_path = $File::Find::name;

    # This is not the droid you are looking for
    if ( $this_file !~ /[.](gif|jpeg|jpg|png)$/xmsi ) {
        return;
    }

    # Make sure the output root exists
    my $out_dir = $this_path;
    $out_dir =~ s{$opt_inroot}{}xmsg;
    $out_dir =~ s{/$}{}xms;
    $out_dir =~ s{^/}{}xms;
    $out_dir =~ s{/}{-}xmsg;
    my $this_outroot = $opt_outroot;
    $this_outroot =~ s{/$}{}xms;
    $this_outroot .= "/${out_dir}";
    if (! -d $this_outroot) {
        mkdir $this_outroot
          or croak("ERROR: creating output root $this_outroot");
    }

    # Store the raw file
    my $raw_dir = $this_outroot . '/raw';
    if (! -d $raw_dir) {
        mkdir $raw_dir
          or croak("ERROR: creating raw directory $raw_dir");
    }

    my $raw_full_path = "${raw_dir}/${this_file}";
    dbg("Processing $this_full_path");
    if (!-e $raw_full_path || $opt_replace) {
        dbg(" Copying raw file to $raw_full_path");
        copy($this_full_path, $raw_full_path)
          or croak "ERROR: problem copying $this_full_path to $raw_full_path";
    }
    generate_sizes($this_full_path, $this_outroot, $this_file);
    $CNT++;

    return;
}

# ------------------------------------------------
# Generate image files of several sizes

sub generate_sizes {
    my ($in_file, $out_root, $out_file) = @_;

    my $work_to_do;
    if ($opt_replace) {
        $work_to_do = 1;
    } else {
        for my $size_id (sort keys %PICTURE_SIZES) {
            my $x = $PICTURE_SIZES{$size_id}{'x'};
            my $y = $PICTURE_SIZES{$size_id}{'y'};
            if ($x == 0) {
                next;
            }
            # Create output directory if necessary
            my $out_path = $out_root . '/' . $size_id;
            if (! -d $out_path) {
                $work_to_do = 1;
                last;
            }
            my $out_full_path = $out_path . "/${out_file}";
            if (!-e $out_full_path) {
                $work_to_do = 1;
                last;
            }
        }
    }

    if (!$work_to_do) {
        return;
    }
    
    # read the image
    my $this_pic = new Image::Magick;
    $this_pic->Read($in_file);
    my ($width, 
        $height, 
        $size, 
        $format, 
        $compression) 
        = $this_pic->Get('width',
                        'height',
                        'filesize',
                        'format',
                        'compression');

    if ($opt_debug) {
        dbg ("      format: $format");
        dbg (" compression: $compression");
        dbg ("       width: $width");
        dbg ("      height: $height");
    }

    # Make sure it is a jpeg image
    if ($compression ne 'JPEG') {
        $this_pic->Set(compression=>'JPEG');
        $compression = 'JPEG';
    }
    my $ptype   = "image/$compression";
    
    # Create the image file to store
    my @pic_blob = $this_pic->ImageToBlob();

    # Extract the EXIF data - not used here but useful for debugging
    my $info = ImageInfo(\@pic_blob[0]);
    my $this_camera       = ${$info}{'Model'};
    my $this_datetime     = ${$info}{'CreateDate'};
    my $this_shutterspeed = ${$info}{'ShutterSpeed'};
    my $this_fnumber      = ${$info}{'FNumber'};
    my $this_raw_size     = length $pic_blob[0];
    if ($opt_debug) {
        dbg ("        size: $this_raw_size");
        dbg ("       model: $this_camera");
        dbg ("    datetime: $this_datetime");
        dbg ("exposuretime: $this_shutterspeed");
        dbg ("     fnumber: $this_fnumber");
        dbg ("EXIF Information ==============================");
        foreach my $t (keys %{$info}) {
            print "$t = ${$info}{$t}\n";
        }
        dbg ("EXIF Information end ==========================");
    }

    for my $size_id (sort keys %PICTURE_SIZES) {
        my $max_x = $PICTURE_SIZES{$size_id}{'x'};
        my $max_y = $PICTURE_SIZES{$size_id}{'y'};
        if ($max_x == 0) {
            next;
        }

        # Set the picture size
        my $x = $width;
        my $y = $height;
        my $x1 = $max_x;
        my $y1 = ($x1/$width) * $height;
        my $y2 = $max_y;
        my $x2 = ($y2/$height) * $width;
        if ($x1 < $x2) {
            $x = $x1;
            $y = $y1;
        } else {
            $x = $x2;
            $y = $y2;
        }
        
        # Create output directory if necessary
        my $out_path = $out_root . '/' . $size_id;
        if ($opt_debug) { dbg("creating directory ${out_path}"); }
        if (! -d $out_path) {
            mkdir $out_path
                or croak("ERROR: creating directory $out_path");
        }
        my $out_full_path = $out_path . "/${out_file}";
        if (-e $out_full_path && !$opt_replace) {
            next;
        }

        dbg (" producing picture $size_id ($x by $y)");

        # Resize the image
        my $resized_pic = Image::Magick->New();
        $resized_pic->BlobToImage(@pic_blob);
        $resized_pic->Resize(width=>$x, height=>$y);
        my @resized_blob = $resized_pic->ImageToBlob();
    
        # Write the output file
        if ($opt_debug) { dbg("opening ${out_full_path} for output"); }
        open(my $fh, '>', $out_full_path)
            or croak("ERROR: opening $out_full_path for output");
        print $fh $resized_blob[0]
            or croak("ERROR: writing to $out_full_path");
        close $fh
            or croak("ERROR: closing file $out_full_path");
    }
    return;
}

##############################################################################
# Main Routine
##############################################################################

print ">>> ring-make-files\n";

# -- get options
GetOptions(
    'db=s'      => \$opt_db,
    'db-host=s' => \$opt_db_host,
    'db-pass=s' => \$opt_db_pass,
    'db-user=s' => \$opt_db_user,
    'debug'     => \$opt_debug,
    'help'      => \$opt_help,
    'inroot=s'  => \$opt_inroot,
    'manual'    => \$opt_manual,
    'outroot=s' => \$opt_outroot,
    'replace'   => \$opt_replace,
    'update'    => \$opt_update
    );

# -- help the poor souls out
if ($opt_help) {
    pod2usage(-verbose => 0);
}
if ($opt_manual) {
    pod2usage(-verbose => 2);
}

if ($opt_debug) {dbg('Initialzie debugging');}

if (!$opt_db_pass) {
    print "%MAC-F-PASSREQ, a MySQL password is required\n";
    pod2usage(-verbose => 1);
}
if (!$opt_db_user) {
    print "%MAC-F-USERREQ, a MySQL username is required\n";
    pod2usage(-verbose => 1);
}

if ($opt_debug) {dbg ("Initialize timer");}

# -- Open up connections to the MySQL data

my $dbi = "dbi:mysql:host=$opt_db_host;database=$opt_db";
$DBH = DBI->connect ($dbi, $opt_db_user, $opt_db_pass)
    or die "%MAC-F-CANTCONN, Can't connect to database $dbi for read\n";

print "Examining files that match $TYPE_LIST\n";

$CNT = 0;
%PICTURE_SIZES = read_picture_sizes();

if ($opt_debug) { dbg("Scanning $opt_inroot"); }
my @dirs = ($opt_inroot);
find(\&make_picture_files, @dirs);
print "$CNT pictures processed\n";

$DBH->disconnect
    or croak("ERROR: Disconnect failed for $dbi (read)");

exit;

__END__

=head1 NAME

ring-make-files

=head1 SYNOPSIS

ring-make-files [--inroot=directory-path] [--outroot=/srv/rings]
                [--update] [--db-host=mysql-host] [--db=dbname]
                --db-user=mysql-username --db-pass=mysql-password
                [--debug] [--help] [--manual]


=head1 DESCRIPTION

Read picture files in a directory tree and create a set of pictures
scaled from the original picture in a parallel directory tree.

=head1 OPTIONS AND ARGUMENTS

=over 4

=item --inroot=directory-path

The location of the input pictures.

=item --outroot=/srv/rings

The location to write picture files to.  The default is /srv/rings.

=item --db-host=mysql-hostname

MySQL host name.

=item --db=database-name

MySQL database name.  If not specified then rings is used.

=item --db-user=mysql-username

MySQL username.  Required.

=item --db-host=mysql-password

MySQL password.  Required.

=item --update

Actually create the files.

=item --help

Displays help text.

=item --manual

Displays more complete help text.

=item --debug

Turns on debugging displays.

=back

=head1 AUTHOR

Bill MacAllister <bill@ca-zephyr.org>

=cut

